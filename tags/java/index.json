[
    {
        "ref": "http://yenvhang.github.io/posts/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/",
        "title": "守护线程",
        "section": "posts",
        "tags": ["java"],
        "date" : "2019.12.04",
        "body": "守护线程与用户线程 守护线程 Daemon Thread 依赋于用户线程，如果JVM 中存在一个或一个以上的非守护线程，那么该线程就不会被结束。\n Thread dameonThread = new Thread(); dameonThread.setDaemon(true); 用户线程 User Thread 与守护线程不同的是，该线程在代码结束完后就会被回收。\n测试代码 守护线程 Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026quot;child thread begin running\u0026quot;); try { Thread.sleep(60 * 1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); thread.setDaemon(true); thread.start(); Thread.sleep(1000);  守护线程会在非守护进程结束后马上结束\n  1S 后\n 用户线程 Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026quot;child thread begin running\u0026quot;); try { Thread.sleep(60 * 1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); thread.setDaemon(false); thread.start(); Thread.sleep(1000);  运行后\n  30S 后 线程依旧存在\n "
    }
,
    {
        "ref": "http://yenvhang.github.io/posts/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/",
        "title": "线程状态",
        "section": "posts",
        "tags": ["java"],
        "date" : "2019.12.03",
        "body": " 线程状态 背景  发生OOM 之后通过 jstack 获取线程信息，当看到一堆线程状态的时候会有点迷，不知道各种线程状态具体代表的是什么意义,RUNABLE 很好理解，但是 BLOCKED,TIMED_WAITING 和 WAITING 具体有什么区别呢，CPU 又是处于一个什么样的利用状态呢？\n 带着这个疑惑翻了下Java Thread类\npublic enum State { /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * {@link Object#wait() Object.wait}. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * \u0026lt;ul\u0026gt; * \u0026lt;li\u0026gt;{@link Object#wait() Object.wait} with no timeout\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link #join() Thread.join} with no timeout\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link LockSupport#park() LockSupport.park}\u0026lt;/li\u0026gt; * \u0026lt;/ul\u0026gt; * * \u0026lt;p\u0026gt;A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called \u0026lt;tt\u0026gt;Object.wait()\u0026lt;/tt\u0026gt; * on an object is waiting for another thread to call * \u0026lt;tt\u0026gt;Object.notify()\u0026lt;/tt\u0026gt; or \u0026lt;tt\u0026gt;Object.notifyAll()\u0026lt;/tt\u0026gt; on * that object. A thread that has called \u0026lt;tt\u0026gt;Thread.join()\u0026lt;/tt\u0026gt; * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * \u0026lt;ul\u0026gt; * \u0026lt;li\u0026gt;{@link #sleep Thread.sleep}\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link Object#wait(long) Object.wait} with timeout\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link #join(long) Thread.join} with timeout\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link LockSupport#parkNanos LockSupport.parkNanos}\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link LockSupport#parkUntil LockSupport.parkUntil}\u0026lt;/li\u0026gt; * \u0026lt;/ul\u0026gt; */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; } 线程有NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED 这些状态\nNEW ​\t线程刚创建未调用start时 的状态\nRUNNABLE ​\t线程创建好后调用start,处于运行中或者等待CPU调度的状态\nBLOCKED ​\t阻塞在synchornized 同步代码块外面的状态\nWAITING ​\t调用object.wait thread.join LockSupport.park 时的状态\nTIMED_WAITING ​\t调用WAITING 类操作但指定了等待时间\nTERMINATED ​\t线程执行完毕的时候\n测试代码 public class ThreadTest { public static final int ONE_MINUTE_IN_MILLIS = 60000; private static Object object = new Object(); private static Object object2 = new Object(); public static void main(String[] args) throws InterruptedException { ThreadTest threadTest = new ThreadTest(); new Thread(() -\u0026gt; threadTest.waitObject(), \u0026#34;thread1\u0026#34;).start(); new Thread(() -\u0026gt; threadTest.waitMethod(), \u0026#34;thread2\u0026#34;).start(); new Thread(() -\u0026gt; threadTest.waitMethod(), \u0026#34;thread3\u0026#34;).start(); Thread.sleep(ONE_MINUTE_IN_MILLIS * 2); new Thread(() -\u0026gt; threadTest.notifyObject(), \u0026#34;thread4\u0026#34;).start(); Thread.sleep(ONE_MINUTE_IN_MILLIS * 3); } /** * 测试 阻塞在 object.wait时 线程的状态 */ public void waitObject() { synchronized (object) { try { object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } /** * 释放 object.wait */ public void notifyObject() { synchronized (object) { object.notify(); } } /** * 测试 阻塞在 进入synchronize 代码块时 线程的状态 */ public void waitMethod() { synchronized (object2) { try { Thread.sleep(ONE_MINUTE_IN_MILLIS * 1); } catch (InterruptedException e) { e.printStackTrace(); } } } } 上述代码会启动三个线程。\nThread1 测试object.await（）时线程的状态。\nThread2 获取object2 的锁后 调用 Thread.sleep(two_min);测试Thread.sleep 时线程的状态。\nThread3 获取object2 锁失败会被阻塞在 synchornized 代码块外面。\n如上图，代码刚运行的时候\nthread1 调用object.wait 处于WAITING 状态。\nthread2 调用 thread.sleep 处于 TIMED_WAITING 状态。\nthread3 阻塞在synchornized 代码块外面处于 BLOCKED 状态。\n一分钟后 thread2 sleep 结束，释放object2 锁。thread3 抢占到了object2 锁，从 BLOCKED 状态变成了 TIMED_WAITING。\n两分钟后 由于两分钟后调用object.notify()。thread1被唤醒，从而结束线程\nthread1 也因为 thread.sleep(onw_min) 的时间到了，结束线程\n所以只剩这个Main 线程了\n"
    }
]
