[
    {
        "ref": "http://yenvhang.github.io/posts/zstack-simpleflowchain%E8%A7%A3%E6%9E%90/",
        "title": "Zstack SimpleFlowChain解析",
        "section": "posts",
        "tags": ["zstack"],
        "date" : "2018.12.27",
        "body": "Zstack SimpleFlowChain 解析 初始化的时候加载指定Flow 对象到 Listflows 对象中。\n执行start 时，拿出第一个Flow,判断是否需要 skip\nprivate boolean isSkipFlow(Flow flow) { Boolean skip = FieldUtils.getFieldValue(\u0026#34;__skip__\u0026#34;, flow); boolean ret = skip != null \u0026amp;\u0026amp; skip; if (ret) { logger.debug(String.format(\u0026#34;[FlowChain: %s] skip flow[%s] because it\u0026#39;s __skip__ set to true\u0026#34;, name, getFlowName(flow))); } return ret; } 这段代码不理解的地方是 为什么不通过 在Flow 中加入一个 isSkipFlow 方法，让Flow实现类 通过 重写方法的形式去 决定要不要 跳过 当前FLow。\n而Zstack 中的这段代码 是通过往实现类 中 写入一个 skip 字段 来决定是否需要 跳过此类。 这对于二次开发来说非常非常的不友好，本身zstack 就没有 提供很好的开发文档，要实现跳过当前的Flow 的功能，还要阅读一下FlowChain 的源码。\n个人认为annotation 的方式都比 skip 的可读性 高上一百倍。重复一遍Zstack垃圾！！\ncurrentFlow = toRun; String flowName = getFlowName(currentFlow); String info = String.format(\u0026quot;[FlowChain(%s): %s] start executing flow[%s]\u0026quot;, id, name, flowName); logger.debug(info); collectAfterRunnable(toRun); toRun.run(this, data); 接着\n如果不需要skip ,则执行该Flow。\n执行该Flow 前，设置currentFlow 为 当前Flow。接着打印 该Flow 的信息。Flow 的信息又是特码通过在 Flow 实现类中 设置 __name__字段\nString name = FieldUtils.getFieldValue(\u0026quot;__name__\u0026quot;, flow); if (name == null) { name = flow.getClass().getSimpleName(); if (name.equals(\u0026quot;\u0026quot;)) { name = flow.getClass().getName(); } } 紧接着还需要 收集一下各种runnable 方法\nprivate void collectAfterRunnable(Flow flow) { List\u0026lt;Field\u0026gt; ad = FieldUtils.getAnnotatedFieldsOnThisClass(AfterDone.class, flow.getClass()); for (Field f : ad) { List lst = FieldUtils.getFieldValue(f.getName(), flow); if (lst != null) { afterDone.add(lst); } } ad = FieldUtils.getAnnotatedFieldsOnThisClass(AfterError.class, flow.getClass()); for (Field f : ad) { List lst = FieldUtils.getFieldValue(f.getName(), flow); if (lst != null) { afterError.add(lst); } } ad = FieldUtils.getAnnotatedFieldsOnThisClass(AfterFinal.class, flow.getClass()); for (Field f : ad) { List lst = FieldUtils.getFieldValue(f.getName(), flow); if (lst != null) { afterFinal.add(lst); } } } AfterDone，AfterError，AfterFinal 注解的字段分别被加到 FlowChain 的 afterDone,afterError,afterFinal 中\n在接着执行完toRun.run 方法之后，start 方法似乎就结束了，那执行完当前Flow，怎么开始下一个Flow 的执行呢。\n我们仔细观察下 toRun.run 的参数，没错，FlowChain 对象 被传到Flow 的run 方法中去了，所以是否执行下一个Flow,是放在当前Flow 中决定的。（疑问：那我Flow 如果执行的时候抛异常了呢？怎么控制我跑到ErrorHandler里面去？？）\n我们参考CreateVMFlow 的代码来看一下FlowChain 接下去的 执行流程\nbus.send(cmsg, new CloudBusCallBack(cmsg) { @Override public void run(MessageReply reply) { if (reply.isSuccess()) { CreateVmInstanceReply creply = (CreateVmInstanceReply) reply; // 设置vm uuid vmUuid = creply.getInventory().getUuid(); inventory.setVmUuid(creply.getInventory().getUuid()); CreateVmEvent.RunData runData = new CreateVmEvent.RunData(); runData.standardDataBaseInstanceData = inventory; runData.vmInstanceInventory = creply.getInventory(); for (BackupDBFlowExtension ext : pluginRgty.getExtensionList(BackupDBFlowExtension.class)) { ext.handleFlowEvent(CreateVmEvent.RUN, runData, inventory); } trigger.next(); } else { trigger.fail(reply.getError()); } } }); 如果消息响应成功，\npublic void next() { if (!isStart) { throw new CloudRuntimeException( String.format(\u0026quot;[FlowChain(%s): %s] you must call start() first, and only call next() in Flow.run()\u0026quot;, id, name)); } if (isRollbackStart) { throw new CloudRuntimeException( String.format(\u0026quot;[FlowChain(%s): %s] rollback has started, you can't call next()\u0026quot;, id, name)); } rollBackFlows.push(currentFlow); 把当前flow 加到 rollBackFlows 中，用于后续回滚操作。\n如果消息响应失败\npublic void fail(ErrorCode errorCode) { isFailCalled = true; setErrorCode(errorCode); rollBackFlows.push(currentFlow); rollback(); } 同样把当前flow 加到 rollBackFlows中。\n接着看rollback 方法\npublic void rollback() { if (!isFailCalled) { throw new CloudRuntimeException(\u0026quot;rollback() cannot be called before fail() is called\u0026quot;); } isRollbackStart = true; if (rollBackFlows.empty()) { callErrorHandler(true); return; } if (skipRestRollbacks) { List\u0026lt;String\u0026gt; restRollbackNames = CollectionUtils.transformToList(rollBackFlows, new Function\u0026lt;String, Flow\u0026gt;() { @Override public String call(Flow arg) { return arg.getClass().getSimpleName(); } }); logger.debug(String.format(\u0026quot;[FlowChain(%s): %s] we are instructed to skip rollbacks for remaining flows%s\u0026quot;, id, name, restRollbackNames)); callErrorHandler(true); return; } if (currentRollbackFlow != null) { logger.debug(String.format(\u0026quot;[FlowChain(%s): %s] successfully rolled back flow[%s]\u0026quot;, id, name, getFlowName(currentRollbackFlow))); } else { logger.debug(String.format(\u0026quot;[FlowChain(%s): %s] start to rollback\u0026quot;, id, name)); } Flow flow = rollBackFlows.pop(); currentRollbackFlow = flow; rollbackFlow(flow); rollBack 方法中 判断要不要跳过后续的所有flow 的回滚方法，直接跑到errorHandler中。\n这个skipRestRollbacks 在哪里设置后面再说。\n如果不跳过呢，执行当前flow 的rollBack 方法。\n依次循环，是否继续rollBack 完全取决于 下一个flow 中 rollback 方法中的实现。\n如果当前flow 不想执行后续的rollBack，那就在rollBack的实现方法中调用 flowChain 的skipRestRollbacks。\npublic void skipRestRollbacks() { skipRestRollbacks = true; } 当然这还不够。这就是zstack 坑人的地方。\n明明这个方法是个skip 动词，它确只是 修改了个状态值，然后！！方法就结束了，flowChain 对象在 triger.next 或 triger.fail 的传递中 突然在这一步skipRestRollBacks 方法中结束了！！这时候flowChain 对象没有被任何东西引用到，就被gc 回收了，可是！之前定义的finallyHandler 和 errorHandler 还没执行呢。\n要实现 不执行后续rollBack 的需求\nflow 的 rollBack 应该这么写\npublic void rollback(FlowRollback trigger, Map data) { trigger.skipRestRollbacks(); trigger.rollback(); } 个人认为这个 trigger.rollback（） 应该 写在skipRestRollback中，这样可读性更高。但我们无法修改ztsack 的原生代码只能妥协。\n不过我补写了个SkipRestRollbackFlow 类\npublic abstract class SkipRestRollbackFlow implements Flow { @Override public void rollback(FlowRollback trigger, Map data) { trigger.skipRestRollbacks(); trigger.rollback(); } } 想实现此功能的flow 只需要继承该SkipRestRollbackFlow 即可。\nflowChain 的rollBack 往往是为了回滚操作释放资源，但有些flow 发生错误 不去回滚，就是为了保留错误现场，以帮助dba 排除问题。\n也有这样一种业务场景，某个flow 发生了错误，但我不希望他回滚，也不希望他停下来，而是在错误上执行去执行下一个flow,最后的时候再去调用errorHandler\n那我们可以在flow 的run 方法中 调用\ntrigger.setError(err); trigger.next(); 这样就可以实现 跳过所有rollBack 方法，直接去执行errorHandler\n可以从下面的代码中得到证明。\npublic void next() { if (!isStart) { throw new CloudRuntimeException( String.format(\u0026quot;[FlowChain(%s): %s] you must call start() first, and only call next() in Flow.run()\u0026quot;, id, name)); } if (isRollbackStart) { throw new CloudRuntimeException( String.format(\u0026quot;[FlowChain(%s): %s] rollback has started, you can't call next()\u0026quot;, id, name)); } rollBackFlows.push(currentFlow); logger.debug(String.format(\u0026quot;[FlowChain(%s): %s] successfully executed flow[%s]\u0026quot;, id, name, getFlowName(currentFlow))); Flow flow = getFirstNotSkippedFlow(); if (flow == null) { // no flows, or all flows are skipped if (errorCode == null) { callDoneHandler(); } else { callErrorHandler(false); } } else { runFlow(flow); } } 如果取出的flow 为空（最后一个flow 执行完了）\n如果errorCode 不为空，那就是去 errorHandler\n否则执行 doneHandler。\n如果取出的flow不为空。\n依次调用，直到 flow 为空。\n"
    }
]
