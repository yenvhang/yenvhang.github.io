[
    {
        "ref": "http://yenvhang.github.io/posts/my-first-post/",
        "title": "FastJson Feature",
        "section": "posts",
        "tags": ["framework"],
        "date" : "2020.02.25",
        "body": "FastJson Feature FastJson 在序列化和反序列化的过程中提供了很多特性,比如Feature.DisableFieldSmartMatch。如果没有选择该Feature,那么在反序列的过程中，FastJson 会自动把下划线命名的Json字符串转化到驼峰式命名的Java对象字段中。\npublic enum Feature { /** * */ AutoCloseSource, /** * */ AllowComment, /** * */ AllowUnQuotedFieldNames, /** * */ AllowSingleQuotes, /** * */ InternFieldNames, /** * */ AllowISO8601DateFormat, /** * {\u0026quot;a\u0026quot;:1,,,\u0026quot;b\u0026quot;:2} */ AllowArbitraryCommas, /** * */ UseBigDecimal, /** * @since 1.1.2 */ IgnoreNotMatch, /** * @since 1.1.3 */ SortFeidFastMatch, /** * @since 1.1.3 */ DisableASM, /** * @since 1.1.7 */ DisableCircularReferenceDetect, /** * @since 1.1.10 */ InitStringFieldAsEmpty, /** * @since 1.1.35 * */ SupportArrayToBean, /** * @since 1.2.3 * */ OrderedField, /** * @since 1.2.5 * */ DisableSpecialKeyDetect, /** * @since 1.2.9 */ UseObjectArray, /** * @since 1.2.22, 1.1.54.android */ SupportNonPublicField, /** * @since 1.2.29 * * disable autotype key '@type' */ IgnoreAutoType, /** * @since 1.2.30 * * disable field smart match, improve performance in some scenarios. */ DisableFieldSmartMatch, /** * @since 1.2.41, backport to 1.1.66.android */ SupportAutoType, /** * @since 1.2.42 */ NonStringKeyAsString, /** * @since 1.2.45 */ CustomMapDeserializer, /** * @since 1.2.55 */ ErrorOnEnumNotMatch ; Feature(){ mask = (1 \u0026lt;\u0026lt; ordinal()); } 每一个Feature，都会被设置一个Mask： int mask = (1 \u0026laquo; ordinal()); ordinal 是Feature在枚举中的位置\n设置默认的features static { int features = 0; features |= Feature.AutoCloseSource.getMask(); features |= Feature.InternFieldNames.getMask(); features |= Feature.UseBigDecimal.getMask(); features |= Feature.AllowUnQuotedFieldNames.getMask(); features |= Feature.AllowSingleQuotes.getMask(); features |= Feature.AllowArbitraryCommas.getMask(); features |= Feature.SortFeidFastMatch.getMask(); features |= Feature.IgnoreNotMatch.getMask(); DEFAULT_PARSER_FEATURE = features; } 判断feature 是否打开 return (features \u0026amp; feature.mask) != 0; 开启feature features |= feature.mask; 关闭feature features \u0026amp;= ~feature.mask; 结论 单个接口要提供灵活的功能，可以参考这种实现方式。\n"
    }
,
    {
        "ref": "http://yenvhang.github.io/posts/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/",
        "title": "守护线程",
        "section": "posts",
        "tags": ["java"],
        "date" : "2019.12.04",
        "body": "守护线程与用户线程 守护线程 Daemon Thread 依赋于用户线程，如果JVM 中存在一个或一个以上的非守护线程，那么该线程就不会被结束。\n Thread dameonThread = new Thread(); dameonThread.setDaemon(true); 用户线程 User Thread 与守护线程不同的是，该线程在代码结束完后就会被回收。\n测试代码 守护线程 Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026quot;child thread begin running\u0026quot;); try { Thread.sleep(60 * 1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); thread.setDaemon(true); thread.start(); Thread.sleep(1000);  守护线程会在非守护进程结束后马上结束\n  1S 后\n 用户线程 Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026quot;child thread begin running\u0026quot;); try { Thread.sleep(60 * 1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); thread.setDaemon(false); thread.start(); Thread.sleep(1000);  运行后\n  30S 后 线程依旧存在\n "
    }
,
    {
        "ref": "http://yenvhang.github.io/posts/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/",
        "title": "线程状态",
        "section": "posts",
        "tags": ["java"],
        "date" : "2019.12.03",
        "body": " 线程状态 背景  发生OOM 之后通过 jstack 获取线程信息，当看到一堆线程状态的时候会有点迷，不知道各种线程状态具体代表的是什么意义,RUNABLE 很好理解，但是 BLOCKED,TIMED_WAITING 和 WAITING 具体有什么区别呢，CPU 又是处于一个什么样的利用状态呢？\n 带着这个疑惑翻了下Java Thread类\npublic enum State { /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * {@link Object#wait() Object.wait}. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * \u0026lt;ul\u0026gt; * \u0026lt;li\u0026gt;{@link Object#wait() Object.wait} with no timeout\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link #join() Thread.join} with no timeout\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link LockSupport#park() LockSupport.park}\u0026lt;/li\u0026gt; * \u0026lt;/ul\u0026gt; * * \u0026lt;p\u0026gt;A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called \u0026lt;tt\u0026gt;Object.wait()\u0026lt;/tt\u0026gt; * on an object is waiting for another thread to call * \u0026lt;tt\u0026gt;Object.notify()\u0026lt;/tt\u0026gt; or \u0026lt;tt\u0026gt;Object.notifyAll()\u0026lt;/tt\u0026gt; on * that object. A thread that has called \u0026lt;tt\u0026gt;Thread.join()\u0026lt;/tt\u0026gt; * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * \u0026lt;ul\u0026gt; * \u0026lt;li\u0026gt;{@link #sleep Thread.sleep}\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link Object#wait(long) Object.wait} with timeout\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link #join(long) Thread.join} with timeout\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link LockSupport#parkNanos LockSupport.parkNanos}\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link LockSupport#parkUntil LockSupport.parkUntil}\u0026lt;/li\u0026gt; * \u0026lt;/ul\u0026gt; */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; } 线程有NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED 这些状态\nNEW ​\t线程刚创建未调用start时 的状态\nRUNNABLE ​\t线程创建好后调用start,处于运行中或者等待CPU调度的状态\nBLOCKED ​\t阻塞在synchornized 同步代码块外面的状态\nWAITING ​\t调用object.wait thread.join LockSupport.park 时的状态\nTIMED_WAITING ​\t调用WAITING 类操作但指定了等待时间\nTERMINATED ​\t线程执行完毕的时候\n测试代码 public class ThreadTest { public static final int ONE_MINUTE_IN_MILLIS = 60000; private static Object object = new Object(); private static Object object2 = new Object(); public static void main(String[] args) throws InterruptedException { ThreadTest threadTest = new ThreadTest(); new Thread(() -\u0026gt; threadTest.waitObject(), \u0026#34;thread1\u0026#34;).start(); new Thread(() -\u0026gt; threadTest.waitMethod(), \u0026#34;thread2\u0026#34;).start(); new Thread(() -\u0026gt; threadTest.waitMethod(), \u0026#34;thread3\u0026#34;).start(); Thread.sleep(ONE_MINUTE_IN_MILLIS * 2); new Thread(() -\u0026gt; threadTest.notifyObject(), \u0026#34;thread4\u0026#34;).start(); Thread.sleep(ONE_MINUTE_IN_MILLIS * 3); } /** * 测试 阻塞在 object.wait时 线程的状态 */ public void waitObject() { synchronized (object) { try { object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } /** * 释放 object.wait */ public void notifyObject() { synchronized (object) { object.notify(); } } /** * 测试 阻塞在 进入synchronize 代码块时 线程的状态 */ public void waitMethod() { synchronized (object2) { try { Thread.sleep(ONE_MINUTE_IN_MILLIS * 1); } catch (InterruptedException e) { e.printStackTrace(); } } } } 上述代码会启动三个线程。\nThread1 测试object.await（）时线程的状态。\nThread2 获取object2 的锁后 调用 Thread.sleep(two_min);测试Thread.sleep 时线程的状态。\nThread3 获取object2 锁失败会被阻塞在 synchornized 代码块外面。\n如上图，代码刚运行的时候\nthread1 调用object.wait 处于WAITING 状态。\nthread2 调用 thread.sleep 处于 TIMED_WAITING 状态。\nthread3 阻塞在synchornized 代码块外面处于 BLOCKED 状态。\n一分钟后 thread2 sleep 结束，释放object2 锁。thread3 抢占到了object2 锁，从 BLOCKED 状态变成了 TIMED_WAITING。\n两分钟后 由于两分钟后调用object.notify()。thread1被唤醒，从而结束线程\nthread1 也因为 thread.sleep(onw_min) 的时间到了，结束线程\n所以只剩这个Main 线程了\n"
    }
,
    {
        "ref": "http://yenvhang.github.io/posts/zstack-simpleflowchain%E8%A7%A3%E6%9E%90/",
        "title": "Zstack SimpleFlowChain解析",
        "section": "posts",
        "tags": ["zstack"],
        "date" : "2018.12.27",
        "body": "Zstack SimpleFlowChain 解析 初始化的时候加载指定Flow 对象到 Listflows 对象中。\n执行start 时，拿出第一个Flow,判断是否需要 skip\nprivate boolean isSkipFlow(Flow flow) { Boolean skip = FieldUtils.getFieldValue(\u0026#34;__skip__\u0026#34;, flow); boolean ret = skip != null \u0026amp;\u0026amp; skip; if (ret) { logger.debug(String.format(\u0026#34;[FlowChain: %s] skip flow[%s] because it\u0026#39;s __skip__ set to true\u0026#34;, name, getFlowName(flow))); } return ret; } 这段代码不理解的地方是 为什么不通过 在Flow 中加入一个 isSkipFlow 方法，让Flow实现类 通过 重写方法的形式去 决定要不要 跳过 当前FLow。\n而Zstack 中的这段代码 是通过往实现类 中 写入一个 skip 字段 来决定是否需要 跳过此类。 这对于二次开发来说非常非常的不友好，本身zstack 就没有 提供很好的开发文档，要实现跳过当前的Flow 的功能，还要阅读一下FlowChain 的源码。\n个人认为annotation 的方式都比 skip 的可读性 高上一百倍。重复一遍Zstack垃圾！！\ncurrentFlow = toRun; String flowName = getFlowName(currentFlow); String info = String.format(\u0026quot;[FlowChain(%s): %s] start executing flow[%s]\u0026quot;, id, name, flowName); logger.debug(info); collectAfterRunnable(toRun); toRun.run(this, data); 接着\n如果不需要skip ,则执行该Flow。\n执行该Flow 前，设置currentFlow 为 当前Flow。接着打印 该Flow 的信息。Flow 的信息又是特码通过在 Flow 实现类中 设置 __name__字段\nString name = FieldUtils.getFieldValue(\u0026quot;__name__\u0026quot;, flow); if (name == null) { name = flow.getClass().getSimpleName(); if (name.equals(\u0026quot;\u0026quot;)) { name = flow.getClass().getName(); } } 紧接着还需要 收集一下各种runnable 方法\nprivate void collectAfterRunnable(Flow flow) { List\u0026lt;Field\u0026gt; ad = FieldUtils.getAnnotatedFieldsOnThisClass(AfterDone.class, flow.getClass()); for (Field f : ad) { List lst = FieldUtils.getFieldValue(f.getName(), flow); if (lst != null) { afterDone.add(lst); } } ad = FieldUtils.getAnnotatedFieldsOnThisClass(AfterError.class, flow.getClass()); for (Field f : ad) { List lst = FieldUtils.getFieldValue(f.getName(), flow); if (lst != null) { afterError.add(lst); } } ad = FieldUtils.getAnnotatedFieldsOnThisClass(AfterFinal.class, flow.getClass()); for (Field f : ad) { List lst = FieldUtils.getFieldValue(f.getName(), flow); if (lst != null) { afterFinal.add(lst); } } } AfterDone，AfterError，AfterFinal 注解的字段分别被加到 FlowChain 的 afterDone,afterError,afterFinal 中\n在接着执行完toRun.run 方法之后，start 方法似乎就结束了，那执行完当前Flow，怎么开始下一个Flow 的执行呢。\n我们仔细观察下 toRun.run 的参数，没错，FlowChain 对象 被传到Flow 的run 方法中去了，所以是否执行下一个Flow,是放在当前Flow 中决定的。（疑问：那我Flow 如果执行的时候抛异常了呢？怎么控制我跑到ErrorHandler里面去？？）\n我们参考CreateVMFlow 的代码来看一下FlowChain 接下去的 执行流程\nbus.send(cmsg, new CloudBusCallBack(cmsg) { @Override public void run(MessageReply reply) { if (reply.isSuccess()) { CreateVmInstanceReply creply = (CreateVmInstanceReply) reply; // 设置vm uuid vmUuid = creply.getInventory().getUuid(); inventory.setVmUuid(creply.getInventory().getUuid()); CreateVmEvent.RunData runData = new CreateVmEvent.RunData(); runData.standardDataBaseInstanceData = inventory; runData.vmInstanceInventory = creply.getInventory(); for (BackupDBFlowExtension ext : pluginRgty.getExtensionList(BackupDBFlowExtension.class)) { ext.handleFlowEvent(CreateVmEvent.RUN, runData, inventory); } trigger.next(); } else { trigger.fail(reply.getError()); } } }); 如果消息响应成功，\npublic void next() { if (!isStart) { throw new CloudRuntimeException( String.format(\u0026quot;[FlowChain(%s): %s] you must call start() first, and only call next() in Flow.run()\u0026quot;, id, name)); } if (isRollbackStart) { throw new CloudRuntimeException( String.format(\u0026quot;[FlowChain(%s): %s] rollback has started, you can't call next()\u0026quot;, id, name)); } rollBackFlows.push(currentFlow); 把当前flow 加到 rollBackFlows 中，用于后续回滚操作。\n如果消息响应失败\npublic void fail(ErrorCode errorCode) { isFailCalled = true; setErrorCode(errorCode); rollBackFlows.push(currentFlow); rollback(); } 同样把当前flow 加到 rollBackFlows中。\n接着看rollback 方法\npublic void rollback() { if (!isFailCalled) { throw new CloudRuntimeException(\u0026quot;rollback() cannot be called before fail() is called\u0026quot;); } isRollbackStart = true; if (rollBackFlows.empty()) { callErrorHandler(true); return; } if (skipRestRollbacks) { List\u0026lt;String\u0026gt; restRollbackNames = CollectionUtils.transformToList(rollBackFlows, new Function\u0026lt;String, Flow\u0026gt;() { @Override public String call(Flow arg) { return arg.getClass().getSimpleName(); } }); logger.debug(String.format(\u0026quot;[FlowChain(%s): %s] we are instructed to skip rollbacks for remaining flows%s\u0026quot;, id, name, restRollbackNames)); callErrorHandler(true); return; } if (currentRollbackFlow != null) { logger.debug(String.format(\u0026quot;[FlowChain(%s): %s] successfully rolled back flow[%s]\u0026quot;, id, name, getFlowName(currentRollbackFlow))); } else { logger.debug(String.format(\u0026quot;[FlowChain(%s): %s] start to rollback\u0026quot;, id, name)); } Flow flow = rollBackFlows.pop(); currentRollbackFlow = flow; rollbackFlow(flow); rollBack 方法中 判断要不要跳过后续的所有flow 的回滚方法，直接跑到errorHandler中。\n这个skipRestRollbacks 在哪里设置后面再说。\n如果不跳过呢，执行当前flow 的rollBack 方法。\n依次循环，是否继续rollBack 完全取决于 下一个flow 中 rollback 方法中的实现。\n如果当前flow 不想执行后续的rollBack，那就在rollBack的实现方法中调用 flowChain 的skipRestRollbacks。\npublic void skipRestRollbacks() { skipRestRollbacks = true; } 当然这还不够。这就是zstack 坑人的地方。\n明明这个方法是个skip 动词，它确只是 修改了个状态值，然后！！方法就结束了，flowChain 对象在 triger.next 或 triger.fail 的传递中 突然在这一步skipRestRollBacks 方法中结束了！！这时候flowChain 对象没有被任何东西引用到，就被gc 回收了，可是！之前定义的finallyHandler 和 errorHandler 还没执行呢。\n要实现 不执行后续rollBack 的需求\nflow 的 rollBack 应该这么写\npublic void rollback(FlowRollback trigger, Map data) { trigger.skipRestRollbacks(); trigger.rollback(); } 个人认为这个 trigger.rollback（） 应该 写在skipRestRollback中，这样可读性更高。但我们无法修改ztsack 的原生代码只能妥协。\n不过我补写了个SkipRestRollbackFlow 类\npublic abstract class SkipRestRollbackFlow implements Flow { @Override public void rollback(FlowRollback trigger, Map data) { trigger.skipRestRollbacks(); trigger.rollback(); } } 想实现此功能的flow 只需要继承该SkipRestRollbackFlow 即可。\nflowChain 的rollBack 往往是为了回滚操作释放资源，但有些flow 发生错误 不去回滚，就是为了保留错误现场，以帮助dba 排除问题。\n也有这样一种业务场景，某个flow 发生了错误，但我不希望他回滚，也不希望他停下来，而是在错误上执行去执行下一个flow,最后的时候再去调用errorHandler\n那我们可以在flow 的run 方法中 调用\ntrigger.setError(err); trigger.next(); 这样就可以实现 跳过所有rollBack 方法，直接去执行errorHandler\n可以从下面的代码中得到证明。\npublic void next() { if (!isStart) { throw new CloudRuntimeException( String.format(\u0026quot;[FlowChain(%s): %s] you must call start() first, and only call next() in Flow.run()\u0026quot;, id, name)); } if (isRollbackStart) { throw new CloudRuntimeException( String.format(\u0026quot;[FlowChain(%s): %s] rollback has started, you can't call next()\u0026quot;, id, name)); } rollBackFlows.push(currentFlow); logger.debug(String.format(\u0026quot;[FlowChain(%s): %s] successfully executed flow[%s]\u0026quot;, id, name, getFlowName(currentFlow))); Flow flow = getFirstNotSkippedFlow(); if (flow == null) { // no flows, or all flows are skipped if (errorCode == null) { callDoneHandler(); } else { callErrorHandler(false); } } else { runFlow(flow); } } 如果取出的flow 为空（最后一个flow 执行完了）\n如果errorCode 不为空，那就是去 errorHandler\n否则执行 doneHandler。\n如果取出的flow不为空。\n依次调用，直到 flow 为空。\n"
    }
,
    {
        "ref": "http://yenvhang.github.io/posts/logger%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%BB%A5%E5%8F%8Alogger%E7%9A%84%E8%8E%B7%E5%8F%96/",
        "title": "Logger配置文件加载以及Logger的获取",
        "section": "posts",
        "tags": ["log"],
        "date" : "2018.05.03",
        "body": "我们在上一篇文章中了解到了SLF4J 是如何找到StaticLoggerBinder,然后通过StaticLoggerBinder 返回 ILoggerFactory。再通过ILoggerFactory 获取Logger。 这一节我们主要来看一下Log4j 中 ILoggerFactory 的实现类 和Logger 的实现类。\n首先是Log4jLoggerFactory\nLog4jLoggerFactory 实现了ILoggerFactory 接口。 并提供了一个 存放 Logger 的容器。\n先来看一下它的构造器。\n在Log4jLoggerFactory 的构造方法中会先去 初始化一个 存放Logger 的CocurrentHashMap 容器。 调用getLogger 时。会优先从该容器中获取 Logger。 如果不存在，则委托LoggerManager 去获取 Logger 对象。 再往下看。 第17 行。 有一个Log4jLoggerAdapter。 此Logger 非彼Logger。 从LoggerManager 获取的Logger 并没有实现 Slf4j 的Logger接口。而是去继承了Category。实现的是一个AppenderAttachable 的接口。 所以需要通过Log4jLoggerAdapter 适配器类 将 基类是Category 的Logger 转换成 实现了 Slf4j 中Logger接口 的Looger类。\n为什么LoggerManager 不直接去实现SLF4J.Logger 接口而是非要弄一个适配器类？ Log4jLoggerFactory 为什么不直接去获取Logger 而是 把它委托给LogManager 呢？ 我们来看一下LoggerManager 的结构。 LogManager 的getLogger 方法又 委托了LoggerRepository去 实现。。\n在LogManager 的静态方法中。获取配置文件地址，加载配置文件（Log4j.xml或者其它)并抽象化，再配置到LoggerRepository 中。\nOptionConverter 获取Configurator 对象（抽象化）。 Configurator.doConfigure() 加载配置文件 并与LoggerRepository 整合。 "
    }
,
    {
        "ref": "http://yenvhang.github.io/posts/slf4j%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B/",
        "title": "Slf4j绑定过程",
        "section": "posts",
        "tags": ["log"],
        "date" : "2018.04.25",
        "body": " slf4j 作为一个日志接口。定义了实现日志框架的一些规范。那么slfj 是如何找到它的实现类呢？\n首先我们引入slf4j org.slf4jslf4j-api1.7.24参考官方文档写法\n import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class HelloWorld { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\u0026quot;Hello World\u0026quot;); } }  运行后 有如下异常信息 大概能猜到 是因为少了某些类。 根据错误信息一步步定位到代码位置。 调用getLogger方法后执行 初始化方法 performInitialization(); 再进入Bind 方法 在17行我们找到了错误信息的来源。这里应该能猜到是因为JVM 运行的时候找不到StaticLoggerBinder类。 参考 slf4j 的实现框架log4j 的StaticLoggerBinder类。 新建了一个自己的StaticLoggerBind类。\n如上。我们再去运行一下我们那段hello代码。程序就能正常运行了。 因为new 出来的Logger 类 没有真正去实现info方法。所有没有任何日志输出。 流程：调用SLF4J 中的LoggerFactory.getLogger 方法后会先去获取ILoggerFactory对象。 获取该工厂对象时，会根据状态来判断是否 执行初始化方法。 在初始话方法中 加载StaticLoggerBinder类。 通过ClasssLoader.getResource(\u0026ldquo;org/slf4j/impl/StaticLoggerBinder.class\u0026rdquo;) 判断是否绑定了多个StaticLoggerBinder。并对比SLF4J 支持的版本号和StatiLoggerBinder 中提供的版本号。 通过ClassLoader 去检查是否有多个StatiLoggerBinder.class。 再把ILoggerFactory 对象的返回 委托给 StatiLoggerBinder去实现。 StatiLoggerBinder返回ILoggerFactory后再通过ILoogerFactory 去获取Logger 对象。\n"
    }
]
